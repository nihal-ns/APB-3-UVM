# APB-3-UVM
<img width="833" height="492" alt="image(1)" src="https://github.com/user-attachments/assets/2ca9f79f-0040-4e31-8d6f-7723d457207e" />

---

## Testbench Architecture

The testbench architecture follows a standard UVM structure, promoting modularity and reuse. It consists of an active agent for driving transactions, a passive agent for monitoring, and a scoreboard for checking data integrity.

### Key Components
* **`apb_agent`**: Encapsulates the driver, sequencer, and monitor. The environment uses both an active and a passive agent.
* **`apb_sequencer` & `apb_sequence`**: The sequencer controls the flow of `apb_seq_item` transactions, which are generated by various sequences to create interesting stimulus.
* **`apb_driver`**: Drives the sequence items onto the APB interface according to the bus protocol.
* **`apb_monitor`**: Passively monitors the APB interface and broadcasts observed transactions to the scoreboard.
* **`apb_scoreboard`**: Checks for functional correctness by comparing transactions captured by the active and passive monitors.
* **`apb_env`**: The top-level environment that instantiates and connects all the major verification components.
* **`apb_test`**: The base test class from which all specific tests are derived. It configures the environment and selects the primary sequence to run.
* **`apb_coverage`**: Collects **functional coverage** metrics to measure how thoroughly the DUT has been tested.
* **`apb_assertion`**: Contains **SystemVerilog Assertions (SVA)** to perform protocol checks and catch illegal bus behavior.
---

## Directory Structure
```
/
├── Doc/
│   └── Links_for_documents.md
├── src/
│   ├── apb_agent.sv
│   ├── apb_assertion.sv
│   ├── apb_coverage.sv
│   ├── apb_driver.sv
│   ├── apb_env.sv
│   ├── apb_interface.sv
│   ├── apb_monitor.sv
│   ├── apb_pkg.sv
│   ├── apb_scoreboard.sv
│   ├── apb_seq_item.sv
│   ├── apb_sequence.sv
│   ├── apb_sequencer.sv
│   ├── apb_test.sv
│   ├── apbtop.v
│   ├── makefile
│   ├── master.v
│   ├── slave1.v
│   ├── slave2.v
│   └── top.sv
└── README.md
```
## How to Run Simulation

A `Makefile` is provided to simplify the compilation and simulation process.

### Prerequisites

* A SystemVerilog simulator that supports UVM, such as **QuestaSim**, **Cadence Xcelium**, or **Synopsys VCS**.

### Commands

The following commands can be run from your terminal in the project's **root directory**.

1.  **Run the default simulation:**
    This compiles the design and runs the default test (`apb_test`) with normal verbosity.
    ```sh
    make
    ```

2.  **Run a specific test:**
    You can specify which test to run by setting the `test` variable.
    ```sh
    make test=<test_name>
    ```
    *Example:* `make test=write_read_test`

3.  **Change UVM Verbosity:**
    You can run any test with a higher verbosity level using the `h` (HIGH) and `d` (DEBUG) targets.
    * For high verbosity:
        ```sh
        make h
        ```
    * For debug verbosity (maximum output):
        ```sh
        make d
        ```

4.  **Combine Test Selection and Verbosity:**
    You can specify a test and a verbosity level in the same command.
    ```sh
    make h test=write_read_test
    ```

5.  **Clean up generated files:**
    This command removes the `work` directory, log files, and waveform files.
    ```sh
    make clean
    ```
